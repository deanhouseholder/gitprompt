#!/bin/bash
#
# MENU WITH SCROLLING SUPPORT (OPTIMIZED FOR NO FLICKER, FIXED NAVIGATION, HEADER, AND SELECTION OUTPUT)
#
menu() {
  main_menu() {
    local i input key selected menu_array menu_fg menu_bg menu_marker header
    local LANG=C.UTF-8
    local default_marker=$'\u27A4'
    local default_highlight_fg="\e[38;5;15m"
    local default_highlight_bg="\e[48;5;4m"
    local key_esc=$'\x1B'
    local key_enter1=$'\x0A'
    local key_enter2=$'\x0D'
    local key_tab=$'\x09'
    local key_up1=$'\e[A'
    local key_up2=$'\eOA'
    local key_down1=$'\e[B'
    local key_down2=$'\eOB'
    local key_left1=$'\e[D'
    local key_left2=$'\eOD'
    local key_right1=$'\e[C'
    local key_right2=$'\eOC'
    local key_home1=$'\e[H'
    local key_home2=$'\eOH'
    local key_ctrl_a=$'\x01'
    local key_end1=$'\e[F'
    local key_end2=$'\eOF'
    local key_ctrl_e=$'\x05'
    local key_pgup1=$'\e[5~'
    local key_pgup2=$'\e[5;2~'
    local key_pgdn1=$'\e[6~'
    local key_pgdn2=$'\e[6;2~'

    if [[ -z "$1" ]]; then echo "Error: No menu header submitted!" >&2; return 255; fi
    header="$1"
    shift

    if [[ -z "$1" ]]; then echo "Error: No menu submitted!" >&2; return 255; fi

    if [[ -v $2 ]]; then
      local menu_array=("$@")
    else
      if declare -p "$1" 2>/dev/null | grep -q '^declare \-a'; then
        local tmp=$1[@]
        local menu_array=("${!tmp}")
      else
        local menu_array=("$1")
      fi
    fi

    selected=0
    local ROWS=$(tput lines)
    local visible_count=$(( ROWS - 5 ))  # Reserve 2 for header, 1 for up arrow, 1 for down arrow, 1 for buffer
    local window_top=0
    local last_selected=-1
    local last_window_top=-1

    [[ ! -v menu_fg ]] && menu_fg=$default_highlight_fg
    [[ ! -v menu_bg ]] && menu_bg=$default_highlight_bg
    [[ ! -v menu_marker ]] && menu_marker="$default_marker"

    # Initialize screen
    tput civis >&2
    printf "\033[?1049h" >&2  # Switch to alternate screen buffer
    printf "\033[2J" >&2      # Clear screen once
    printf "\033[1;1H" >&2    # Move to top-left
    printf "%s\n\n" "$header" >&2  # Print header

    display_menu() {
      local output=""
      local end=$(( window_top + visible_count ))
      (( end > ${#menu_array[@]} )) && end=${#menu_array[@]}

      # Move cursor to line 3 (below header and blank line)
      output+="\033[3;1H"

      # Clear from cursor to end of screen
      output+="\033[J"

      # Show up arrow if scrolled down
      if (( window_top > 0 )); then
        output+="   ↑ ...\n"
      else
        output+="\n"
      fi

      # Build menu items
      for (( i=window_top; i<end; i++ )); do
        if (( i == selected )); then
          output+="${menu_fg}${menu_bg} ${menu_marker} ${menu_array[$i]}\e[0m\n"
        else
          output+="   ${menu_array[$i]}\n"
        fi
        [[ "$menu_padding" == 1 ]] && output+="\n"
      done

      # Show down arrow if more items below
      if (( end < ${#menu_array[@]} )); then
        output+="   ↓ ...\n"
      fi

      # Print the entire menu in one go
      printf "%b" "$output" >&2
    }

    read_keypress() {
      local keypress byte
      keypress=""
      IFS= read -rsN1 byte
      while [[ -n $byte ]]; do
        keypress+="$byte"
        IFS= read -rsN1 -t 0.005 byte || break
      done
      printf "%s" "$keypress"
    }

    while true; do
      # Only redraw if selection or window position changed
      if (( selected != last_selected || window_top != last_window_top )); then
        display_menu
        last_selected=$selected
        last_window_top=$window_top
      fi

      input=$(read_keypress)

      case "$input" in
        "$key_esc"|'q'|'Q')
          printf "\033[2J" >&2      # Clear screen
          printf "\033[?1049l" >&2  # Restore main screen buffer
          tput cnorm >&2
          return 255
        ;;

        "$key_up1"|"$key_up2")
          ((selected--))
          if (( selected < 0 )); then
            selected=$(( ${#menu_array[@]} - 1 ))
            window_top=$(( selected - visible_count + 1 ))
            (( window_top < 0 )) && window_top=0
          elif (( selected < window_top )); then
            window_top=$selected
          fi
        ;;

        "$key_down1"|"$key_down2")
          ((selected++))
          if (( selected >= ${#menu_array[@]} )); then
            selected=0
            window_top=0
          elif (( selected >= window_top + visible_count )); then
            window_top=$(( selected - visible_count + 1 ))
          fi
        ;;

        "$key_left1"|"$key_left2")
          # Optionally treat left as up
          ((selected--))
          if (( selected < 0 )); then
            selected=$(( ${#menu_array[@]} - 1 ))
            window_top=$(( selected - visible_count + 1 ))
            (( window_top < 0 )) && window_top=0
          elif (( selected < window_top )); then
            window_top=$selected
          fi
        ;;

        "$key_right1"|"$key_right2")
          # Optionally treat right as down
          ((selected++))
          if (( selected >= ${#menu_array[@]} )); then
            selected=0
            window_top=0
          elif (( selected >= window_top + visible_count )); then
            window_top=$(( selected - visible_count + 1 ))
          fi
        ;;

        "$key_pgup1"|"$key_pgup2")
          # Scroll up one screenful
          window_top=$(( window_top - visible_count ))
          selected=$(( selected - visible_count ))
          if (( window_top < 0 )); then
            window_top=0
            selected=$(( selected < 0 ? 0 : selected ))
          fi
        ;;

        "$key_pgdn1"|"$key_pgdn2")
          # Scroll down one screenful
          window_top=$(( window_top + visible_count ))
          selected=$(( selected + visible_count ))
          if (( window_top + visible_count > ${#menu_array[@]} )); then
            window_top=$(( ${#menu_array[@]} - visible_count ))
            (( window_top < 0 )) && window_top=0
            selected=$(( selected >= ${#menu_array[@]} ? ${#menu_array[@]} - 1 : selected ))
          fi
        ;;

        "$key_home1"|"$key_home2"|"$key_ctrl_a")
          selected=0
          window_top=0
        ;;

        "$key_end1"|"$key_end2"|"$key_ctrl_e")
          selected=$(( ${#menu_array[@]} - 1 ))
          window_top=$(( selected - visible_count + 1 ))
          (( window_top < 0 )) && window_top=0
        ;;

        "$key_enter1"|"$key_enter2"|"$key_tab"|''|' ')
          printf "\033[2J" >&2      # Clear screen
          printf "\033[?1049l" >&2  # Restore main screen buffer
          tput cnorm >&2
          printf "%d" "$selected"   # Output selected index to stdout
          return 0
        ;;
      esac
    done
  }

  tput clear >&2 2>/dev/null || clear >&2
  export menu_msg menu_selected menu_status
  menu_msg=""
  menu_selected=""
  # Capture main_menu output and status
  menu_selected=$(main_menu "$@")
  local status=$?
  # Trim any whitespace
  menu_selected=$(echo "$menu_selected" | tr -d '[:space:]')
  if [[ $status -eq 0 && -n "$menu_selected" ]]; then
    # Validate as numeric using string check
    if [[ "$menu_selected" =~ ^[0-9]+$ ]]; then
      menu_status=0
      return 0
    else
      menu_msg="Error: Invalid selection index"
      menu_status=1
      menu_selected=""
      return 1
    fi
  else
    menu_msg=$([[ $status -eq 255 ]] && echo "Canceled" || echo "Error: Invalid selection index")
    menu_status=1
    menu_selected=""
    return 1
  fi
}